<!-- templates/edit_question.html -->
{% extends "base.html" %}
{% block title %}問題編集{% endblock %}

{% block content %}
<h2>問題編集</h2>
<style>
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    input[type=number] {
      -webkit-appearance: none;
      appearance: none;
      -moz-appearance: textfield;
    }
    .sub-question {
      border: 1px solid #ddd;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 4px;
    }
    .sub-question > div {
      margin-bottom: 5px;
    }
    .sub-question label {
      font-weight: bold;
    }
</style>
<form method="post" action="{{ url_for('save_question', quest_id=quest_id, question_id=question.id if question else 'new') }}">
  <input type="hidden" name="title" value="{{ title }}">
  <input type="hidden" name="level" value="{{ level }}">
  <label>タイプ:</label>
  <select name="type" id="type-select">
    <option value="choice" {% if question and question.type == 'choice' %}selected{% endif %}>4択問題</option>
    <option value="multiple_choice" {% if question and question.type == 'multiple_choice' %}selected{% endif %}>複数選択</option>
    <option value="sort" {% if question and question.type == 'sort' %}selected{% endif %}>並び替え</option>
    <option value="numeric" {% if question and question.type == 'numeric' %}selected{% endif %}>数値入力</option>
    <option value="fill_in_the_blank_en" {% if question and question.type == 'fill_in_the_blank_en' %}selected{% endif %}>英語穴埋め</option>
    <option value="svg_interactive" {% if question and question.type == 'svg_interactive' %}selected{% endif %}>図形問題</option>
  </select>

  <label>問題文（Markdown）:</label>
  <textarea name="text" id="text-input" rows="4" cols="60">{{ question.text if question else '' }}</textarea>
  <div id="text-preview" class="markdown-preview" style="margin-bottom: 1rem;"></div>

  <label>解説（Markdown）:</label>
  <textarea name="explanation" id="explanation-input" rows="4" cols="60">{{ question.explanation or '' }}</textarea>
  <div id="explanation-preview" class="markdown-preview" style="margin-bottom: 1rem;"></div>

  <div id="choice-section" style="display:none;">
    <label>選択肢:</label><br>
    {% for i in range(4) %}
      <input type="text" name="choice{{ i }}" id="choice{{ i }}" value="{{ choices[i] if question and (question.type == 'choice' or question.type == 'multiple_choice') and question.choices|length > i else '' }}"><br>
      <div id="choice{{ i }}_preview" class="markdown-preview" style="margin-bottom: 0.5rem;"></div>
    {% endfor %}
    <label>正解:</label>
    <input type="text" name="answer" value="{{ question.answer if question and (question.type == 'choice' or question.type == 'multiple_choice') else '' }}" placeholder="単一選択は正解、複数選択はカンマ区切り（例: A,C）">
  </div>

  <div id="sort-section" style="display:none;">
    <label>正解の並び順（文字列）:</label>
    <input type="text" name="answer_sort" value="{% if question and question.type == 'sort' %}{{ question.answer or '' }}{% endif %}">
  </div>

  <div id="numeric-section" style="display:none;">
    {% for i in range(4) %}
      <label>Label {{ i + 1 }}:</label>
      <input type="text" name="label{{ i }}" value="{{ question.answers[i]['label'] if question and question.type == 'numeric' and question.answers|length > i else '' }}">
      <label>Answer {{ i + 1 }}:</label>
      <input type="number" name="num_answer{{ i }}" value="{{ question.answers[i]['answer'] if question and question.type == 'numeric' and question.answers|length > i else '' }}"><br>
    {% endfor %}
  </div>

  <div id="fill-in-the-blank-en-section" style="display:none;">
    <label>正解（英語）:</label>
    <input type="text" name="answer_fill_in_the_blank_en" value="{{ question.answer if question and question.type == 'fill_in_the_blank_en' else '' }}">
  </div>

  <div id="svg-interactive-section" style="display:none;">
    <label>SVGコンテンツ:</label>
    <textarea name="svg_content" id="svg-content-textarea" rows="10" cols="60">{{ question.choices if question and question.type == 'svg_interactive' else '' }}</textarea><br>
    <button type="button" id="svg-preview-button" class="button">SVGプレビュー</button><br>
    <label>追加文:</label>
    <div id="sub-questions-container">
      {% if question and question.type == 'svg_interactive' and answers %}
        {% for sub_q in answers %}
          <div class="sub-question">
            <input type="hidden" name="sub_id" value="{{ sub_q.id }}">
            <div>
              <label>問題文 (Markdown):</label>
              <textarea name="sub_prompt" rows="2" cols="50" class="sub-prompt-input">{{ sub_q.prompt }}</textarea>
              <div class="markdown-preview sub-prompt-preview"></div>
            </div>
            <div>
              <label>正答:</label>
              <input type="text" name="sub_answer" placeholder="正答" value="{{ sub_q.answer }}">
            </div>
            <button type="button" class="remove-sub-question">削除</button>
          </div>
        {% endfor %}
      {% endif %}
    </div>
    <button type="button" id="add-sub-question">追加文を追加</button>
  </div>

<!-- 保存ボタン：上段 -->
<br>
<button type="submit" name="action" value="save_question">保存</button>
<!-- 戻るボタン：下段 -->
<div style="margin-top: 1rem;">
  <a href="{{ url_for('edit_quest', quest_id=quest_id, title=title, level=level) }}" class="button">クエスト編集に戻る</a>
</div>
</form>

<style>
  .markdown-preview {
    border: 1px solid #ccc;
    padding: 0.5rem;
    background-color: #f9f9f9;
    border-radius: 4px;
  }
</style>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\(', '\)']],
      displayMath: [['$$', '$$'], ['\[', '\]']]
    },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>

<script>
  // Marked.js の設定を MathJax と共存できるように変更
  marked.setOptions({
    gfm: true,    // GitHub Flavored Markdown を有効にする
    breaks: true  // 改行を <br> に変換する
  });

  const typeSelect = document.getElementById('type-select');
  const choiceSection = document.getElementById('choice-section');
  const sortSection = document.getElementById('sort-section');
  const numericSection = document.getElementById('numeric-section');
  const fillInTheBlankEnSection = document.getElementById('fill-in-the-blank-en-section');
  const svgInteractiveSection = document.getElementById('svg-interactive-section');

  function updateSections() {
    const type = typeSelect.value;
    choiceSection.style.display = (type === 'choice' || type === 'multiple_choice') ? 'block' : 'none';
    sortSection.style.display = type === 'sort' ? 'block' : 'none';
    numericSection.style.display = type === 'numeric' ? 'block' : 'none';
    fillInTheBlankEnSection.style.display = type === 'fill_in_the_blank_en' ? 'block' : 'none';
    svgInteractiveSection.style.display = type === 'svg_interactive' ? 'block' : 'none';
  }

  // 初期表示時に選択肢と問題文のMarkdownをプレビュー
  async function updatePreviews() {
    // text
    try {
      const mdText = document.getElementById("text-input").value;
      const previewDiv = document.getElementById("text-preview");
      previewDiv.innerHTML = marked.parse(mdText || '');
      await MathJax.typesetPromise([previewDiv]);
    } catch (e) {
      console.error("Error updating text preview:", e);
    }

    // explanation
    try {
      const mdExplanation = document.getElementById("explanation-input").value;
      const explanationPreviewDiv = document.getElementById("explanation-preview");
      explanationPreviewDiv.innerHTML = marked.parse(mdExplanation || '');
      await MathJax.typesetPromise([explanationPreviewDiv]);
    } catch (e) {
      console.error("Error updating explanation preview:", e);
    }

    // choices
    for (let i = 0; i < 4; i++) {
      try {
        const input = document.getElementById(`choice${i}`);
        if (input) {
          const preview = document.getElementById(`choice${i}_preview`);
          const md = input.value || '';
          preview.innerHTML = marked.parse(md);
          await MathJax.typesetPromise([preview]);
        }
      } catch (e) {
        console.error(`Error updating choice ${i} preview:`, e);
      }
    }
  }

  // sub-questionのプレビューを更新する関数
  async function updateSubQuestionPreview(inputElement) {
    const preview = inputElement.nextElementSibling;
    preview.innerHTML = marked.parse(inputElement.value);
    await MathJax.typesetPromise([preview]);
  }

  document.addEventListener('DOMContentLoaded', () => {
    // ページ読み込み時にプレビューを更新
    updateSections();
    updatePreviews(); // ここで初期表示時のプレビューも更新

    // イベントリスナー
    typeSelect.addEventListener('change', () => {
      updateSections();
      updatePreviews();
    });

    // 入力内容が変更された場合にプレビューを更新
    document.getElementById("text-input").addEventListener("input", updatePreviews);
    document.getElementById("explanation-input").addEventListener("input", updatePreviews);
    for (let i = 0; i < 4; i++) {
      const input = document.getElementById(`choice${i}`);
      if (input) {
        input.addEventListener("input", updatePreviews);
      }
    }

    // 既存のsub-questionのプレビューを初期化
    document.querySelectorAll('.sub-prompt-input').forEach(input => {
      updateSubQuestionPreview(input);
      input.addEventListener('input', () => updateSubQuestionPreview(input));
    });

    let subQuestionCounter = document.querySelectorAll('.sub-question').length;

    document.getElementById('add-sub-question').addEventListener('click', () => {
      subQuestionCounter++;
      const container = document.getElementById('sub-questions-container');
      const newSubQuestion = document.createElement('div');
      newSubQuestion.classList.add('sub-question');
      newSubQuestion.innerHTML = `
        <input type="hidden" name="sub_id" value="sub${subQuestionCounter}">
        <div>
          <label>問題文 (Markdown):</label>
          <textarea name="sub_prompt" rows="2" cols="50" class="sub-prompt-input"></textarea>
          <div class="markdown-preview sub-prompt-preview"></div>
        </div>
        <div>
          <label>正答:</label>
          <input type="text" name="sub_answer" placeholder="正答">
        </div>
        <button type="button" class="remove-sub-question">削除</button>
      `;
      container.appendChild(newSubQuestion);

      const newInput = newSubQuestion.querySelector('.sub-prompt-input');
      updateSubQuestionPreview(newInput); // 新しい要素のプレビューを初期化
      newInput.addEventListener('input', () => updateSubQuestionPreview(newInput));
    });

    document.getElementById('sub-questions-container').addEventListener('click', (e) => {
      if (e.target.classList.contains('remove-sub-question')) {
        e.target.parentElement.remove();
      }
    });

    // SVGプレビューボタンの処理
    const svgPreviewButton = document.getElementById('svg-preview-button');
    if (svgPreviewButton) {
      svgPreviewButton.addEventListener('click', () => {
        const svgContent = document.getElementById('svg-content-textarea').value;
        const form = document.createElement('form');
        form.method = 'POST';
        form.action = '{{ url_for('main.svg_preview') }}';
        form.target = '_blank'; // 新しいタブで開く

        const hiddenField = document.createElement('input');
        hiddenField.type = 'hidden';
        hiddenField.name = 'svg_data';
        hiddenField.value = svgContent;
        form.appendChild(hiddenField);

        document.body.appendChild(form);
        form.submit();
        document.body.removeChild(form);
      });
    }
  });
</script>

{% endblock %}